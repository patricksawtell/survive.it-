<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>TEst 29 region</title>
	<script type="text/javascript" src="d3/d3.min.js"></script>
	<script src="node_modules/topojson/topojson.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.min.js"></script>
	<script src="node_modules/jquery/dist/jquery.min.js"></script>
	<script src="node_modules/textures/textures.js"></script>
	<script src="liquid.js"></script>
	<style>
		path {
			fill: white;
			stroke: grey;
			stroke-width: 2px;
			font-size: 20px;
			font-weight: 300;
			text-anchor: middle;
		}

		svg {
			background-color:#005F80;
		}

		.clouds{
			height: 500px;
			width: 500px;
			background-image:  url('https://dl.dropboxusercontent.com/u/32750720/cloud-1.png'), url('https://dl.dropboxusercontent.com/u/32750720/cloud-2.png');
			background-position:
			0 100%,
			100% 0;
			background-repeat: no-repeat;
			position: absolute;
			top: 0; left: 0; right: 0; bottom: 0;
			margin: auto;
			transform:
			translateZ(50px);
			pointer-events: none;
			animation: cloud-rotate-h 160s linear infinite;
			transition: all 5s;

		}
		@keyframes cloud-rotate-h {
			0% {
				transform:
				translateZ(50px)
				rotate(0deg);
			}
			50% {
				transform:
				translateZ(50px)
				rotate(180deg);
				width: 60%;
			}
			100% {
				transform:
				translateZ(50px)
				rotate(360deg);
			}
		}
		svg{
			position: absolute;
			top: 0; left: 0; right: 0; bottom: 0;
			margin: auto;
			border: solid 5px black;
		}

	.infect{
		fill:url(#radialGradient);
	}

	</style>
</head>
<body>
<script>

	//Set some SVG default value and some data will be use globally
	var width = 700;
	var height = 700;
	var regionsData = {};
	var svg = d3.select("body")
		.append("svg")
		.attr("width", width)
		.attr("height", height)
		.style("border", "solid 5px black");
	var def = d3.select("svg")
		.append("defs")
		.attr("class","animate");
	var neighborNames;
	var neighborDirection;
	var centered;

	//Read csv file and topo json files
	d3.csv("RegionsBC.csv", function (data) {
		d3.json("bc29.topo.json", function (map) {

			//Initialize the region data in hash
			var geometries = map.objects.bc_29_crs84.geometries;
			geometries.forEach(function (region) {
				var name = region.properties.CDNAME;
				regionsData[name] = {};
				regionsData[name]['infectStatus'] = false;
			});


			//Store the csv data into hash
			for (var i = 0; i < data.length; i++) {
				var regionName = data[i].Name;
				var regionValue = parseFloat(data[i].Population);
				regionsData[regionName]['populatoin'] = regionValue;
			}


			//Draw with pattern
			var t = textures.circles()
				.radius(4)
				.fill("darkorange");

			svg.call(t);
			//Draw the map: could change scale at any size
			var projection = d3.geo.mercator().scale(2000);
			var path = d3.geo.path().projection(projection);
			var featureCollection = topojson.feature(map, map.objects.bc_29_crs84);
			var neighbors = topojson.neighbors(map.objects.bc_29_crs84.geometries);
			var mapJ = svg.selectAll("path")
				.data(featureCollection.features)
				.enter()
				.append("path")
				.attr("d", path)
				.attr("id", function (item) {
					return item.properties.CDNAME;
				})
				.attr("class", "region");
//				.style("fill", t.url());
//Create cloud
			$('<div>').addClass('clouds').appendTo($('body'));


			//Create gradient


			var center = def.append('radialGradient')
				.attr('id','center')
				.attr('cx','0.5')
				.attr('cy', '0.5');

			var right_bottom = def.append('radialGradient')
				.attr('id','right_bottom')
				.attr('cx','1')
				.attr('cy', '1');

			var right_top = def.append('radialGradient')
				.attr('id','right_top')
				.attr('cx','1')
				.attr('cy', '0');

			var right = def.append('radialGradient')
				.attr('id','right')
				.attr('cx','1')
				.attr('cy', '0.5');

			var left = def.append('radialGradient')
				.attr('id','left')
				.attr('cx','0')
				.attr('cy', '0.5');

			var left_top = def.append('radialGradient')
				.attr('id','left_top')
				.attr('cx','0')
				.attr('cy', '0');

			var left_bottom = def.append('radialGradient')
				.attr('id','left_bottom')
				.attr('cx','0')
				.attr('cy', '1');

			var top = def.append('radialGradient')
				.attr('id','top')
				.attr('cx','0.5')
				.attr('cy', '1');

			var bottom = def.append('radialGradient')
				.attr('id','bottom')
				.attr('cx','0.5')
				.attr('cy', '0');

			d3.selectAll("radialgradient").append('stop').attr("offset", "50%")
				.attr("stop-color", "red");
			d3.selectAll("radialgradient").append('stop').attr("offset", "100%")
				.attr("stop-color", "white");

			d3.selectAll("radialgradient").append('animate').attr("attributeName", "r")
				.attr("dur", "12s")
				.attr("from", "0.01")
				.attr("to", "2")
				.attr("repeatCount", "1")
				.attr("fill", "freeze");




			// calculate bounding box coordinate
			var regions = $('svg .region')
				.toArray()
				.map(function (region) {
					if (region.getAttribute('d')) {
						return region.getAttribute('d').split(/[MZ]/).join('').split('L').map(function (s) {
							var pairs = s.split(',');
							return pairs.map(function (n) {
								return parseFloat(n);
							});
						});
					}
				});
			var allCoordinates = _.flatten(regions);

			function getBoundingBox(Coordinates) {
				var result = {};
				result.minX = _.min(Coordinates, function (coordinate) {
					return coordinate[0]
				})[0];
				result.minY = _.min(Coordinates, function (coordinate) {
					return coordinate[1]
				})[1];
				result.maxX = _.max(Coordinates, function (coordinate) {
					return coordinate[0]
				})[0];
				result.maxY = _.max(Coordinates, function (coordinate) {
					return coordinate[1]
				})[1];
				result.width = result.maxX - result.minX;
				result.height = result.maxY - result.minY;
				var marginW = result.width * 0.1;
				var marginH = result.height * 0.1;

				var viewBox = (result.minX - marginW) + ' ' + (result.minY - marginH) + ' ' + (result.width + marginW) + ' ' + (result.height + marginH);
				return viewBox;
			}
			//Set the view Box
			var viewBox = getBoundingBox(allCoordinates);
			$('svg').each(function () {
				$(this)[0].setAttribute('viewBox', viewBox)
			});
			//calculate single bounding box of region
			$('svg .region').toArray().forEach(function(region, index){
				if (region.getAttribute('d')) {
					var regionName = region.getAttribute('id');
					var coordinates = region.getAttribute('d').split(/[MZ]/).join('').split('L').map(function (s) {
						var pairs = s.split(',');
						return pairs.map(function (n) {
							return parseFloat(n);
						});
					});
					coordinates = getBoundingBox(coordinates);
					regionsData[regionName]['bbox'] = coordinates;
					var center = getCenterCoordinate(coordinates, regionName);
					regionsData[regionName]['center'] = center;
				}
			});

			//Get the center of bbox
			function getCenterCoordinate(Coordinates, region) {
				var bbox = regionsData[region]['bbox'].split(' ').map(function(c){
					return parseFloat(c);});
					var x = bbox[0]+(bbox[2]/2);
					var y = bbox[1]+(bbox[3]/2);
					return [x, y];
			}


			//Compare direction of two bregions

			function getDirection(from, to){
				var x1 = from[0], y1 = from[1];
				var x2 = to[0], y2 = to[1];
				if(x1 > x2){
					if(y1 > y2){
						return "right_bottom"
					}else if(y1 < y2){
						return "right_top"
					}else{
						return "right"
					}
				}else if(x1 < x2){
					if(y1 > y2){
						return "left_bottom"
					}else if(y1 < y2){
						return "left_top"
					}else{
					return 	"left"
					}
				}
				else{
					if(y1 < y2){
					return "bottom"
					}else{
					return	"top"
					}
				}
			}

			//Get the spread angle
			//Turn into x y direction

			//Get the neighbor reference list (In region name)
			var getGeoName = function (region) {
				return region.properties.CDNAME;
			};
			var idName = geometries.map(getGeoName);
			var neighbors = topojson.neighbors(geometries);
			var nameMap = function (geoIndex) {
				return getGeoName(geometries[geoIndex]);
			};
			neighborNames = neighbors.reduce(function (valuesSoFar, currentValue, index) {
				var name = idName[index];
				valuesSoFar[name] = currentValue.map(nameMap);
				return valuesSoFar;
			}, {});


			//Get the direction of neighbor

			neighborDirection = neighbors.reduce(function (valuesSoFar, currentValue, index) {
				var name = idName[index];
				valuesSoFar[name] = {};
					currentValue.forEach(function(value, index){
					var result = {};
					var regionName = nameMap(value);
					var fromPoint = regionsData[name]["center"];
					var toPoint = regionsData[regionName]["center"];
						valuesSoFar[name][regionName] = getDirection(fromPoint, toPoint);
				});
				return valuesSoFar;
			}, {});

			//Click event
//			function clicked(d){
//				if (d && centered !== d) {
//					centered = d;
//					var regionName = d.properties.CDNAME;
//					d3.select('svg').transition().duration(1000).attr('viewBox', regionsData[regionName]['bbox'])
//				} else {
//					centered = null;
//					$('svg').each(function () {
//						d3.select('svg').transition().duration(1000).attr('viewBox', viewBox)
//					});
//				}
//			}
		});
	});
	//$(window).click((e) => console.log(e.target))  this is to check what is been clicked
	$(function () {

		$('body').on('input', '#slider', function() {
			console.log('current value: ', $(this).val());
		});

		$('svg').on('click', 'path', function () {

			var currentRegion = $(this).attr('id');
			var getCurrentNeighbors = function (currentRegion) {
				var neighbours = neighborNames[currentRegion];
				return neighbours.filter(function(name) {
					return !regionsData[name].infectStatus;
				});
			};
//			d3.select(this).style('fill', 'url(RadialGradient1)');
			regionsData[currentRegion].infectStatus = true;
			var day = 0;
			var propagationData = [];
			var infectionHistory = [];

			var infect = function(targets) {
				//Check if there is no more targets
				if( !targets.length) {
					console.log('FINISHED');
					$('#slider').show();
					return;
				}

				//Record the infect history
				infectionHistory[day] = targets;
				console.log('Infecting '+targets.length+' new targets on day #'+day);
				console.log(infectionHistory);

				//Set the targets to be true infected status
				targets.forEach(function(target) {
					regionsData[target[0]].infectStatus = true;
				});

				var nextRoundTargets = [];
				//Change the targets color, set the neighbors list for next round
				targets.forEach(function(target, index) {
					var currentTarget = target[0];
					var currentNeighborsList = getCurrentNeighbors(currentTarget);
					//set the next round targets and spread directions
					nextRoundTargets = nextRoundTargets.concat(
							currentNeighborsList.map(function(currentNeighbor) {
								var result = [];
								result[0] = currentNeighbor;
								result[1] = neighborDirection[currentTarget][currentNeighbor];
								return result;
							})
					);
					//Take out the duplicate list
					nextRoundTargets = _.uniq(nextRoundTargets);

					// color the  all infected red
					var direction = targets[index][1];
					d3.select('#' + currentTarget).style('fill', 'url(#'+ direction +')');
				});
				setTimeout(function() {
					day++;
					infect(nextRoundTargets);
				}, 3000);

			};
			infect([[currentRegion , "center"]]);

		});
	});
</script>
</body>
</html>
